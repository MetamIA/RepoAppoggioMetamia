# -*- coding: utf-8 -*-
"""AGENT.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Yusrr4kNpFReRkTRIzoNvks9lp9MGMwO
"""

# ===== CELLA 1: INSTALLAZIONE DIPENDENZE =====
!pip install langchain
!pip install langchain_openai
!pip install langchain_experimental
!pip install openai

print("âœ… Dipendenze installate")

# ===== CELLA 2: SETUP API KEY CORRETTO =====
import os

# âš ï¸ IMPORTANTE: Sostituisci con la tua API key OpenAI
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    raise EnvironmentError(
        "La variabile OPENAI_API_KEY non Ã¨ stata trovata. "
        "Assicurati di averla impostata in ambiente o in un file .env."
    )
# Imposta la variabile ambiente
os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY

# Verifica che sia impostata
if os.environ.get("OPENAI_API_KEY"):
    print("âœ… API Key configurata correttamente")
else:
    print("âŒ API Key non configurata")

print(f"ğŸ”‘ API Key (primi 10 caratteri): {OPENAI_API_KEY[:10]}...")

# ===== CELLA 3: IMPORT E SETUP BASE =====
import pandas as pd
import numpy as np
import pickle
import json
import re
from datetime import datetime

# Import LangChain con gestione errori
try:
    from langchain_experimental.agents.agent_toolkits import create_csv_agent
    print("âœ… langchain_experimental importato")
except ImportError as e:
    print(f"âŒ Errore langchain_experimental: {e}")

try:
    from langchain_openai import ChatOpenAI
    print("âœ… ChatOpenAI importato")
except ImportError as e:
    print(f"âŒ Errore ChatOpenAI: {e}")
    # Fallback import
    try:
        from langchain.chat_models import ChatOpenAI
        print("âœ… ChatOpenAI importato (fallback)")
    except ImportError:
        print("âŒ ChatOpenAI non disponibile - reinstalla langchain-openai")

try:
    from langchain.tools import tool
    from langchain.agents import AgentType, initialize_agent
    from langchain.memory import ConversationBufferMemory
    print("âœ… Langchain tools importati")
except ImportError as e:
    print(f"âŒ Errore langchain tools: {e}")

try:
    from statsmodels.tsa.statespace.sarimax import SARIMAX
    print("âœ… SARIMAX importato")
except ImportError as e:
    print(f"âŒ Errore SARIMAX: {e}")

print("âœ… Import completati")

# ===== CELLA 3.5: VERIFICA INSTALLAZIONI =====
# Verifica che tutti i componenti siano disponibili
print("ğŸ” VERIFICA COMPONENTI:")

# Test API Key
try:
    import os
    if "OPENAI_API_KEY" in os.environ:
        print("âœ… API Key configurata")
    else:
        print("âŒ API Key non configurata")
except:
    print("âŒ Problema con le variabili ambiente")

# Test ChatOpenAI
try:
    test_llm = ChatOpenAI(temperature=0.1)
    print("âœ… ChatOpenAI funziona")
except Exception as e:
    print(f"âŒ ChatOpenAI error: {e}")

    # Prova reinstallazione
    print("ğŸ”„ Tentativo reinstallazione...")
    !pip install --upgrade langchain-openai

    try:
        from langchain_openai import ChatOpenAI
        test_llm = ChatOpenAI(temperature=0.1)
        print("âœ… ChatOpenAI funziona dopo reinstallazione")
    except Exception as e2:
        print(f"âŒ Ancora problemi: {e2}")

print("ğŸ” Verifica completata")

# ===== CELLA 4: VERIFICA FILE NECESSARI =====
import os

# Verifica che i file del modello esistano
required_files = [
    'predizioni_2025_corrette.csv',
    'sarima_model_vendite.pkl'
]

missing_files = []
for file in required_files:
    if os.path.exists(file):
        print(f"âœ… {file}")
    else:
        print(f"âŒ {file} - MANCANTE")
        missing_files.append(file)

if missing_files:
    print(f"\nâš ï¸ ATTENZIONE: File mancanti: {missing_files}")
    print("ğŸ”§ Prima di continuare, esegui completamente biscotti3.py per generare:")
    print("   - predizioni_2025_corrette.csv")
    print("   - sarima_model_vendite.pkl")
else:
    print("\nâœ… Tutti i file necessari sono presenti!")

# ===== CELLA 5: CLASSE SISTEMA IBRIDO =====
class HybridPredictionSystem:
    def __init__(self, csv_path='predizioni_2025_corrette.csv', model_path='sarima_model_vendite.pkl'):

        # Setup paths
        self.csv_path = csv_path
        self.model_path = model_path

        # Setup LLM
        self.llm = ChatOpenAI(temperature=0.1, model="gpt-4")

        # Load components
        print("ğŸ”„ Caricamento componenti...")
        self._load_prediction_model()
        self._setup_rag_agent()
        self._setup_hybrid_agent()

        print("âœ… Sistema Ibrido inizializzato!")

    def _load_prediction_model(self):
        """Carica il modello SARIMA e i dati di supporto"""
        try:
            with open(self.model_path, 'rb') as f:
                self.sarima_system = pickle.load(f)

            self.model_fitted = self.sarima_system['model']
            self.ts_data = self.sarima_system['ts_data']
            self.df_clean = self.sarima_system['df_clean']
            self.timestamps = self.ts_data['timestamp'].values
            self.ts_target = self.ts_data['Kg Venduti'].values

            print("âœ… Modello SARIMA caricato")
        except Exception as e:
            print(f"âŒ Errore caricamento modello: {e}")
            raise

    def _setup_rag_agent(self):
        """Setup agente RAG per CSV"""
        try:
            self.csv_agent = create_csv_agent(
                self.llm,
                self.csv_path,
                verbose=False,
                allow_dangerous_code=True,
                return_intermediate_steps=True
            )
            print("âœ… Agente RAG configurato")
        except Exception as e:
            print(f"âŒ Errore setup RAG: {e}")
            self.csv_agent = None

    def _extract_query_params(self, query):
        """Estrae parametri dalla query utente"""
        patterns = {
            'anno': r'20\d{2}',
            'mese': r'\b(gennaio|febbraio|marzo|aprile|maggio|giugno|luglio|agosto|settembre|ottobre|novembre|dicembre|\d{1,2})\b',
            'prodotto': r'\b\d{4,6}\b'
        }

        params = {}

        # Anno
        year_match = re.search(patterns['anno'], query)
        if year_match:
            params['anno'] = int(year_match.group())

        # Prodotto
        product_match = re.search(patterns['prodotto'], query)
        if product_match:
            params['prodotto'] = int(product_match.group())

        # Mese
        month_match = re.search(patterns['mese'], query.lower())
        if month_match:
            month_text = month_match.group()
            mesi_dict = {
                'gennaio': 1, 'febbraio': 2, 'marzo': 3, 'aprile': 4,
                'maggio': 5, 'giugno': 6, 'luglio': 7, 'agosto': 8,
                'settembre': 9, 'ottobre': 10, 'novembre': 11, 'dicembre': 12
            }

            if month_text in mesi_dict:
                params['mese'] = mesi_dict[month_text]
            elif month_text.isdigit():
                mese_num = int(month_text)
                if 1 <= mese_num <= 12:
                    params['mese'] = mese_num

        return params

    def _check_csv_for_data(self, params):
        """Verifica se i dati esistono nel CSV"""
        try:
            df = pd.read_csv(self.csv_path)

            conditions = []

            if 'anno' in params:
                conditions.append(df['anno'] == params['anno'])
            if 'mese' in params:
                conditions.append(df['mese'] == params['mese'])
            if 'prodotto' in params:
                conditions.append(df['prodotto_id'] == params['prodotto'])

            if conditions:
                filtered_df = df[pd.concat(conditions, axis=1).all(axis=1)]
                return len(filtered_df) > 0, filtered_df

            return False, pd.DataFrame()

        except Exception as e:
            print(f"âŒ Errore verifica CSV: {e}")
            return False, pd.DataFrame()

    def _predict_runtime(self, prodotto_id, anno, mese):
        """Predizione runtime per prodotto specifico"""
        print(f"ğŸ”® Calcolo predizione: Prodotto {prodotto_id}, {anno}-{mese:02d}")

        try:
            # Calcola steps
            target_timestamp = anno * 100 + mese
            ultimo_timestamp = self.timestamps[-1]

            def calc_steps(from_ts, to_ts):
                from_year, from_month = from_ts // 100, from_ts % 100
                to_year, to_month = to_ts // 100, to_ts % 100
                return (to_year - from_year) * 12 + (to_month - from_month)

            steps = calc_steps(ultimo_timestamp, target_timestamp)

            if steps <= 0:
                return None, f"Periodo {anno}-{mese:02d} Ã¨ nel passato"

            # 1. Predizione globale SARIMA
            try:
                forecast = self.model_fitted.forecast(steps=steps)
                pred_global_log = forecast.iloc[-1] if hasattr(forecast, 'iloc') else forecast[-1]
                pred_global_orig = np.expm1(pred_global_log)
            except:
                recent_avg = np.mean(self.ts_target[-12:])
                pred_global_orig = recent_avg

            # 2. Verifica prodotto esistente
            prodotto_data = self.df_clean[self.df_clean['Prodotto'] == prodotto_id]
            if len(prodotto_data) == 0:
                return None, f"Prodotto {prodotto_id} non trovato nel database"

            # 3. Calcola quota prodotto CORRETTA
            prodotto_totale = prodotto_data['Kg Venduti'].sum()
            globale_totale = self.df_clean['Kg Venduti'].sum()
            quota_prodotto = prodotto_totale / globale_totale

            # 4. StagionalitÃ  CORRETTA
            mese_data = prodotto_data[prodotto_data['Periodo'] == mese]
            if len(mese_data) > 0:
                mese_totale = mese_data['Kg Venduti'].sum()
                anni_attivo = prodotto_data['Esercizio'].nunique()
                mese_medio = mese_totale / anni_attivo

                prodotto_medio_mensile = prodotto_totale / (anni_attivo * 12)
                adjustment_stagionale = mese_medio / prodotto_medio_mensile if prodotto_medio_mensile > 0 else 1.0
            else:
                mese_medio = 0
                adjustment_stagionale = 1.0

            # 5. Predizione finale con conversione scala
            pred_prodotto_orig = pred_global_orig * quota_prodotto * adjustment_stagionale

            scale_factor = 1000
            pred_prodotto_realistic = pred_prodotto_orig / scale_factor
            mese_storico_realistic = mese_medio / scale_factor if mese_medio > 0 else 0

            # 6. Variazione
            if mese_storico_realistic > 0:
                variazione_pct = ((pred_prodotto_realistic / mese_storico_realistic) - 1) * 100
            else:
                variazione_pct = 0

            # 7. Ricavi (stima semplificata)
            ricavo_medio = prodotto_data['Ricavo Netto'].mean() if 'Ricavo Netto' in prodotto_data.columns else 0
            kg_medio = prodotto_data['Kg Venduti'].mean()
            ricavo_per_kg = ricavo_medio / kg_medio if kg_medio > 0 else 0
            ricavo_stimato = pred_prodotto_realistic * ricavo_per_kg

            # 8. Risultato formattato
            risultato = {
                'prodotto_id': prodotto_id,
                'rank': 999,  # Runtime
                'anno': anno,
                'mese': mese,
                'mese_nome': ['Gen','Feb','Mar','Apr','Mag','Giu','Lug','Ago','Set','Ott','Nov','Dic'][mese-1],
                'periodo': f"{anno}-{mese:02d}",
                'kg_totali_storici': prodotto_totale,
                'quota_globale_pct': quota_prodotto * 100,
                'storico_mese_kg': mese_storico_realistic,
                'predizione_kg': pred_prodotto_realistic,
                'adjustment_stagionale': adjustment_stagionale,
                'variazione_pct': variazione_pct,
                'ricavo_lordo_stimato': ricavo_stimato,
                'ricavo_netto_stimato': ricavo_stimato,
                'metodo_globale': 'SARIMA_Runtime'
            }

            return risultato, None

        except Exception as e:
            return None, f"Errore calcolo: {str(e)}"

    def _update_csv(self, new_data):
        """Aggiorna CSV con nuove predizioni"""
        try:
            df_existing = pd.read_csv(self.csv_path)
            new_row = pd.DataFrame([new_data])
            df_updated = pd.concat([df_existing, new_row], ignore_index=True)

            # Rimuovi duplicati
            df_updated = df_updated.drop_duplicates(
                subset=['prodotto_id', 'anno', 'mese'],
                keep='last'
            )

            # Salva
            df_updated.to_csv(self.csv_path, index=False)

            # Backup
            backup_path = f"backup_predizioni_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
            df_updated.to_csv(backup_path, index=False)

            print(f"âœ… CSV aggiornato! Backup: {backup_path}")
            return True

        except Exception as e:
            print(f"âŒ Errore aggiornamento: {e}")
            return False

    def _setup_hybrid_agent(self):
        """Setup agente ibrido"""

        @tool
        def hybrid_prediction_tool(query: str) -> str:
            """Tool ibrido per predizioni: cerca nel CSV o calcola runtime"""

            print(f"ğŸ” Query: {query}")

            # Estrai parametri
            params = self._extract_query_params(query)
            print(f"ğŸ“Š Parametri: {params}")

            # Verifica CSV esistente
            has_data, existing_data = self._check_csv_for_data(params)

            if has_data and len(existing_data) > 0:
                print("âœ… Dati trovati nel CSV")

                # Usa RAG
                try:
                    rag_response = self.csv_agent.invoke(query)
                    return f"ğŸ“Š DATI ESISTENTI (CSV):\n{rag_response['output']}"
                except:
                    return f"ğŸ“Š DATI ESISTENTI (CSV):\n{existing_data.to_string()}"

            else:
                print("âŒ Dati non trovati, calcolo runtime...")

                if 'prodotto' in params and 'anno' in params and 'mese' in params:

                    risultato, errore = self._predict_runtime(
                        params['prodotto'],
                        params['anno'],
                        params['mese']
                    )

                    if risultato:
                        # Aggiorna CSV
                        self._update_csv(risultato)

                        return f"""ğŸ”® NUOVA PREDIZIONE CALCOLATA E SALVATA:

ğŸ“… Periodo: {risultato['periodo']} ({risultato['mese_nome']} {risultato['anno']})
ğŸ·ï¸  Prodotto: {risultato['prodotto_id']}
ğŸ¯ Predizione: {risultato['predizione_kg']:.2f} kg
ğŸ“Š Storico stesso mese: {risultato['storico_mese_kg']:.2f} kg
ğŸ“ˆ Variazione vs storico: {risultato['variazione_pct']:+.1f}%
ğŸ’° Ricavo netto stimato: â‚¬{risultato['ricavo_netto_stimato']:.2f}
ğŸ“Š Quota sul totale: {risultato['quota_globale_pct']:.3f}%
âš™ï¸  Fattore stagionale: {risultato['adjustment_stagionale']:.3f}

âœ… Predizione aggiunta al CSV per future consultazioni!"""

                    else:
                        return f"âŒ Errore: {errore}"

                else:
                    return f"âŒ Parametri insufficienti. Servono: ID prodotto, anno, mese.\nTrovati: {params}\n\nğŸ’¡ Esempi corretti:\n- 'Prodotto 40006 maggio 2025'\n- 'Vendite 50000 giugno 2025'\n- 'Predizione 60000 12 2025'"

        # Setup agente con memoria
        self.memory = ConversationBufferMemory(memory_key="chat_history", return_messages=True)

        self.hybrid_agent = initialize_agent(
            tools=[hybrid_prediction_tool],
            llm=self.llm,
            agent=AgentType.CHAT_CONVERSATIONAL_REACT_DESCRIPTION,
            memory=self.memory,
            verbose=True,
            handle_parsing_errors=True
        )

        print("âœ… Agente ibrido pronto")

    def ask(self, query):
        """Metodo principale per domande"""
        try:
            response = self.hybrid_agent.run(query)
            return response
        except Exception as e:
            return f"âŒ Errore: {str(e)}"

print("âœ… Classe HybridPredictionSystem definita")

# ===== CELLA 6: INIZIALIZZAZIONE SISTEMA =====
# Crea il sistema ibrido
print("ğŸš€ Inizializzazione Sistema Ibrido...")

try:
    oracolo = HybridPredictionSystem()
    print("\nğŸ‰ SISTEMA PRONTO!")
    print("ğŸ”® Ora puoi fare domande usando: oracolo.ask('tua domanda')")

except Exception as e:
    print(f"âŒ Errore inizializzazione: {e}")
    print("ğŸ”§ Verifica che i file necessari siano presenti")

# ===== CELLA 7: FUNZIONE DI CHAT INTERATTIVA =====
def chat_interattivo():
    """Chat interattiva con l'oracolo"""

    print("ğŸ¤– ORACOLO IBRIDO ATTIVO!")
    print("="*50)
    print("âœ… Posso consultare dati esistenti e calcolare nuove predizioni")
    print("ğŸ“ Esempi:")
    print("   - 'Vendite prodotto 40006 maggio 2025'")
    print("   - 'Quanto venderemo a giugno 2025?'")
    print("   - 'Predizione prodotto 50000 dicembre 2025'")
    print("ğŸ”„ Scrivi 'stop' per fermare\n")

    while True:
        try:
            domanda = input("ğŸ”® Domanda: ").strip()

            if domanda.lower() in ['stop', 'quit', 'exit']:
                print("ğŸ‘‹ Chat terminata!")
                break

            if not domanda:
                continue

            print("\nğŸ”„ Elaborazione...")
            risposta = oracolo.ask(domanda)
            print(f"\nğŸ¤– Risposta:\n{risposta}\n")
            print("-" * 60)

        except KeyboardInterrupt:
            print("\nğŸ‘‹ Interrotto")
            break
        except Exception as e:
            print(f"\nâŒ Errore: {e}")

print("âœ… Funzione chat_interattivo() pronta")
print("ğŸ® Per avviare la chat: chat_interattivo()")

# ===== CELLA 8: TEST RAPIDI =====
# Test di esempio
print("ğŸ§ª TEST RAPIDI DEL SISTEMA")
print("="*40)

# Test query esistenti
test_queries = [
    "Vendite totali gennaio 2025",
    "Prodotto 40000 maggio 2025",
    "Quanto venderemo del prodotto 50000 a giugno 2025?"
]

for i, query in enumerate(test_queries, 1):
    print(f"\nğŸ” Test {i}: {query}")
    try:
        risultato = oracolo.ask(query)
        print(f"âœ… Risposta ottenuta (lunghezza: {len(risultato)} caratteri)")
    except Exception as e:
        print(f"âŒ Errore: {e}")

print("\nâœ… Test completati!")

# ===== CELLA 9: UTILITY E DIAGNOSTICA =====
def mostra_statistiche_csv():
    """Mostra statistiche del CSV predizioni"""
    try:
        df = pd.read_csv('predizioni_2025_corrette.csv')

        print("ğŸ“Š STATISTICHE CSV PREDIZIONI")
        print("="*40)
        print(f"ğŸ“¦ Totale predizioni: {len(df)}")
        print(f"ğŸ·ï¸  Prodotti unici: {df['prodotto_id'].nunique()}")
        print(f"ğŸ“… Mesi coperti: {sorted(df['mese'].unique())}")
        print(f"ğŸ“ˆ Range predizioni: {df['predizione_kg'].min():.2f} - {df['predizione_kg'].max():.2f} kg")

        print(f"\nğŸ“‹ Top 5 prodotti per predizioni totali:")
        top_prodotti = df.groupby('prodotto_id')['predizione_kg'].sum().sort_values(ascending=False).head()
        for prod_id, kg_tot in top_prodotti.items():
            print(f"   {prod_id}: {kg_tot:.1f} kg")

    except Exception as e:
        print(f"âŒ Errore lettura CSV: {e}")

def verifica_modello():
    """Verifica stato del modello SARIMA"""
    try:
        print("ğŸ” VERIFICA MODELLO SARIMA")
        print("="*30)
        print(f"âœ… Modello caricato: {hasattr(oracolo, 'model_fitted')}")
        print(f"ğŸ“Š Periodi training: {len(oracolo.ts_target)}")
        print(f"ğŸ“… Ultimo timestamp: {oracolo.timestamps[-1]}")
        print(f"ğŸ¯ Ultimo valore: {oracolo.ts_target[-1]:,.0f} kg")

    except Exception as e:
        print(f"âŒ Errore verifica: {e}")

print("âœ… Utility disponibili:")
print("   - mostra_statistiche_csv()")
print("   - verifica_modello()")

# ===== CELLA 10: AVVIA CHAT =====
# Uncomment per avviare automaticamente la chat
# chat_interattivo()

print("ğŸ‰ SISTEMA COMPLETO PRONTO!")
print("ğŸ”® Per iniziare: chat_interattivo()")
print("ğŸ“Š Per statistiche: mostra_statistiche_csv()")
print("ğŸ” Per verifica modello: verifica_modello()")

chat_interattivo()